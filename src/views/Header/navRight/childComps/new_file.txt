一:
层级混乱

二:
使用事件总线进行兄弟组件通信,多次事件发射与接收,导致一系列的低性能优化操作
增加代码量,多处v-show取代v-if,增加负荷

三:
ref与reactive使用界限不明确,不应该全使用reactive响应式数据

四:
当需要等待上一个请求结果传入下一个请求参数时,应使用sync与await配合,而不是通过watch进行上一个请求结果数据监听从而启动下一个数据请求操作以及promise函数回调

五:
在watch监听时不能进行防抖函数的引入,debounce.js,因为找不到上一个timer无法清空,导致出现延时多次点击未防抖
解决方式一:
例子:进入后立即执行清空操作
watchEffect( (onDebounce) => {
				let timer=getKeyWordList(props.searchText)
				onDebounce( () => {
					clearTimeout(timer)
				})
})
解决方式二:
例子:将timer放入响应式数据中保存以便下次清空或者执行
const longPoll = () => {
				if (state.timer) {
					clearTimeout(state.timer)
				}
				// console.log('长轮询开始')
				checkImage(state.unikey, Date.now()).then(res => {
					// console.log(res)
					if (res.code === 801) {
						// console.log(res.message)
					}
					if (res.code === 802) {
						// console.log(res.message)
					}
					if (res.code === 803) {
						// console.log(res)
						return state.userData = res.cookie
					}
					if (res.code === 800) {
						isRefresh.value = true;
						// console.log(res.message)
						return
					}
					state.timer = setTimeout(() => {
						longPoll()
					}, 2000)
				})
			}
六:
vue3中一些功能在setup中使用需要引入并实例化，如路由,事件总线等等
vue3 setup中顺序混乱  1.功能引入2.ref与reactive声明3.钩子函数4接口调用5其他事件处理函数6return所有
七:
未引入配置文件进行路径别名设置
八:
组件库全部引入效率低,应在main.js中按需引入
九:
事件总线与inject，provide
二者传递多个参数时{a:xxx,b:xxx}

例子:
两个必须写在外面 因为setup中有作用域且无this
const internalInstance = getCurrentInstance();
const $bus = internalInstance.appContext.config.globalProperties.$bus

发射与接收可以写在方法和钩子函数中
$bus.emit('myevent',{
	cellphone:state.user.mobile,
	pwd:state.user.password
})

$bus.on('myevent', val=> {
	cellphone.value=val.cellphone
	password.value=val.pwd
})

必须写在外面 因为setup中有作用域且无this
const emitter = inject("emitter");

发射与接收可以写在方法和钩子函数中 provide在main.js中 
emitter.emit("myevent", state.count);

emitter.on('myevent', value => {
	cellphone.value = value
})
